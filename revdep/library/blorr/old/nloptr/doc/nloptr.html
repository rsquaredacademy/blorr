<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Jelmer Ypma, Aymeric Stamm, and Avraham Adler" />

<meta name="date" content="2024-06-24" />

<title>nloptr</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">nloptr</h1>
<h4 class="author">Jelmer Ypma, Aymeric Stamm, and Avraham Adler</h4>
<h4 class="date">2024-06-24</h4>



<p>This document is an introduction to <code>nloptr</code>: an R
interface to NLopt. <a href="https://nlopt.readthedocs.io/en/latest/">NLopt</a> is a
free/open-source library for nonlinear optimization, started by Steven
G. Johnson, providing a common interface for a number of different free
optimization routines available online as well as original
implementations of various other algorithms. The NLopt library is
available under the GNU Lesser General Public License (LGPL), and the
copyrights are owned by a variety of authors. This package should be
considered in beta and comments about any aspect of the package are
welcome. This document is an R vignette prepared with the aid of
<code>knitr</code> <span class="citation">(Xie 2014, 2015, 2016)</span>.
Financial support of the UK Economic and Social Research Council through
a grant (RES-589-28-0001) to the ESRC Centre for Microdata Methods and
Practice (CeMMAP) is gratefully acknowledged.</p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>NLopt addresses general nonlinear optimization problems of the form:
<span class="math display">\[
\begin{aligned}
&amp;\min_{x \in R^n} f(x) \\
s.t.&amp; g(x) \leq 0 \\
&amp; h(x) = 0 \\
&amp; x_L \leq x \leq x_U
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(f(\cdot)\)</span> is the objective
function and <span class="math inline">\(x\)</span> represents the <span class="math inline">\(n\)</span> optimization parameters. This problem
may optionally be subject to the bound constraints (also called box
constraints), <span class="math inline">\(x_L\)</span> and <span class="math inline">\(x_U\)</span>. For partially or totally
unconstrained problems the bounds can take values <span class="math inline">\(-\infty\)</span> or <span class="math inline">\(\infty\)</span>. One may also optionally have
<span class="math inline">\(m\)</span> nonlinear inequality
constraints—sometimes called a nonlinear programming problem—which may
be specified in <span class="math inline">\(g(\cdot)\)</span>, and
equality constraints which may be specified in <span class="math inline">\(h(\cdot)\)</span>. Note that not all of the
algorithms in NLopt can handle constraints.</p>
<p>This vignette describes how to formulate minimization problems to be
solved with the R interface to NLopt. If you want to use the C interface
directly or are interested in the Matlab interface, there are other
sources of documentation available. Some of the information here has
been taken from the NLopt website, where more details are available. All
credit for implementing the C code for the different algorithms
available in NLopt should go to the respective authors. Also, please see
the <a href="https://nlopt.readthedocs.io/en/latest/Citing_NLopt/">website</a>
for information on how to cite NLopt and the algorithms you use.</p>
</div>
<div id="installation" class="section level2">
<h2>Installation</h2>
<p>This package is on CRAN and can be installed from within R using</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&quot;nloptr&quot;</span>)</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&quot;nloptr&quot;</span>, <span class="at">type =</span> <span class="st">&quot;source&quot;</span>)</span></code></pre></div>
<p>to install the package from source. You should now be able to load
the R interface to NLopt and read the help.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;nloptr&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>?nloptr</span></code></pre></div>
<p>The most recent experimental <em>source</em> version of
<code>nloptr</code> can be installed from Github using the
<code>remotes</code> package:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># install.packages(&quot;remotes&quot;)</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>remotes<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">&quot;astamm/nloptr&quot;</span>)</span></code></pre></div>
</div>
<div id="minimizing-the-rosenbrock-banana-function" class="section level2">
<h2>Minimizing the Rosenbrock Banana function</h2>
<p>As a first example we will solve an unconstrained minimization
problem. The function we look at is the Rosenbrock Banana function:
<span class="math display">\[
f(x) = 100 \left(x_2-x_1^2\right)^2 + \left(1-x_1\right)^2,
\]</span></p>
<p>which is also used as an example in the documentation for the
standard R optimizer <code>optim</code>. The gradient of the objective
function is given by: <span class="math display">\[
\nabla f(x) =
\left(\begin{array}[1]{c}
-400 \cdot x_1 \cdot (x_2 - x_1^2) - 2 \cdot (1 - x_1) \\
200 \cdot (x_2 - x_1^2)
\end{array} \right).
\]</span></p>
<p>Not all of the algorithms in NLopt need gradients to be supplied by
the user. We will show examples with and without supplying the gradient.
After loading the library.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">library</span>(nloptr)</span></code></pre></div>
<p>We start by specifying the objective function and its gradient:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="do">## Rosenbrock Banana function</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>eval_f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="dv">100</span> <span class="sc">*</span> (x[<span class="dv">2</span>] <span class="sc">-</span> x[<span class="dv">1</span>] <span class="sc">*</span> x[<span class="dv">1</span>]) <span class="sc">^</span> <span class="dv">2</span> <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">-</span> x[<span class="dv">1</span>]) <span class="sc">^</span> <span class="dv">2</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>}</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="do">## Gradient of Rosenbrock Banana function</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>eval_grad_f <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>  <span class="fu">c</span>(<span class="sc">-</span><span class="dv">400</span> <span class="sc">*</span> x[<span class="dv">1</span>] <span class="sc">*</span> (x[<span class="dv">2</span>] <span class="sc">-</span> x[<span class="dv">1</span>] <span class="sc">*</span> x[<span class="dv">1</span>]) <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> x[<span class="dv">1</span>]),</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    <span class="dv">200</span> <span class="sc">*</span> (x[<span class="dv">2</span>] <span class="sc">-</span> x[<span class="dv">1</span>] <span class="sc">*</span> x[<span class="dv">1</span>]))</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>}</span></code></pre></div>
<p>We define initial values</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># initial values</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>x0 <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">1.2</span>, <span class="dv">1</span>)</span></code></pre></div>
<p>and then minimize the function using the <code>nloptr</code> command.
This command runs some checks on the supplied inputs and returns an
object with the exit code of the solver, the optimal value of the
objective function and the solution. Before we can minimize the function
we need to specify which algorithm we want to use</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>opts <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">&quot;algorithm&quot;</span> <span class="ot">=</span> <span class="st">&quot;NLOPT_LD_LBFGS&quot;</span>,</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>             <span class="st">&quot;xtol_rel&quot;</span> <span class="ot">=</span> <span class="fl">1.0e-8</span>)</span></code></pre></div>
<p>Here we use the L-BFGS algorithm <span class="citation">(Nocedal
1980; Liu and Nocedal 1989)</span>. The characters <code>LD</code> in
the algorithm show that this algorithm looks for local minima
(<code>L</code>) using a derivative-based (<code>D</code>) algorithm.
Other algorithms look for global (<code>G</code>) minima, or they don’t
need derivatives (<code>N</code>). We also specified the termination
criterium in terms of the relative x-tolerance. Other termination
criteria are available (see Appendix <code>\ref{sec:descoptions}</code>
for a full list of options). We then solve the minimization problem
using</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># solve Rosenbrock Banana function</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">nloptr</span>(<span class="at">x0 =</span> x0,</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>              <span class="at">eval_f =</span> eval_f,</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>              <span class="at">eval_grad_f =</span> eval_grad_f,</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>              <span class="at">opts =</span> opts)</span></code></pre></div>
<p>We can see the results by printing the resulting object.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">print</span>(res)</span></code></pre></div>
<pre><code>## 
## Call:
## 
## nloptr(x0 = x0, eval_f = eval_f, eval_grad_f = eval_grad_f, opts = opts)
## 
## 
## 
## Minimization using NLopt version 2.7.1 
## 
## NLopt solver status: 1 ( NLOPT_SUCCESS: Generic success 
## return value. )
## 
## Number of Iterations....: 56 
## Termination conditions:  xtol_rel: 1e-08 
## Number of inequality constraints:  0 
## Number of equality constraints:    0 
## Optimal value of objective function:  5.6213401034694e-23 
## Optimal value of controls: 1 1</code></pre>
<p>Sometimes the objective function and its gradient contain common
terms. To economize on calculations, we can return the objective and its
gradient in a list. For the Rosenbrock Banana function we have for
instance:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="do">## Rosenbrock Banana function and gradient in one function</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>eval_f_list <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  common_term <span class="ot">&lt;-</span> x[<span class="dv">2</span>] <span class="sc">-</span> x[<span class="dv">1</span>] <span class="sc">*</span> x[<span class="dv">1</span>]</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>  <span class="fu">list</span>(<span class="st">&quot;objective&quot;</span> <span class="ot">=</span> <span class="dv">100</span> <span class="sc">*</span> common_term <span class="sc">^</span> <span class="dv">2</span> <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">-</span> x[<span class="dv">1</span>]) <span class="sc">^</span> <span class="dv">2</span>,</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>       <span class="st">&quot;gradient&quot;</span>  <span class="ot">=</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">400</span> <span class="sc">*</span> x[<span class="dv">1</span>] <span class="sc">*</span> common_term <span class="sc">-</span> <span class="dv">2</span> <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> x[<span class="dv">1</span>]),</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>                       <span class="dv">200</span> <span class="sc">*</span> common_term))</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>}</span></code></pre></div>
<p>which we minimize using</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">nloptr</span>(<span class="at">x0 =</span> x0,</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>              <span class="at">eval_f =</span> eval_f_list,</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>              <span class="at">opts =</span> opts)</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="fu">print</span>(res)</span></code></pre></div>
<pre><code>## 
## Call:
## nloptr(x0 = x0, eval_f = eval_f_list, opts = opts)
## 
## 
## Minimization using NLopt version 2.7.1 
## 
## NLopt solver status: 1 ( NLOPT_SUCCESS: Generic success 
## return value. )
## 
## Number of Iterations....: 56 
## Termination conditions:  xtol_rel: 1e-08 
## Number of inequality constraints:  0 
## Number of equality constraints:    0 
## Optimal value of objective function:  5.6213401034694e-23 
## Optimal value of controls: 1 1</code></pre>
<p>This gives the same results as before.</p>
</div>
<div id="minimization-with-inequality-constraints" class="section level2">
<h2>Minimization with inequality constraints</h2>
<p>This section shows how to minimize a function subject to inequality
constraints. This example is the same as the one used in the tutorial on
the NLopt website. The problem we want to solve is:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\min_{x \in R^n} \sqrt{x_2} \\
s.t.&amp; x_2 \geq 0 \\
&amp; x_2 \geq (a_1 x_1 + b_1)^3 \\
&amp; x_2 \geq (a_2 x_1 + b_2)^3,
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(a_1 = 2\)</span>, <span class="math inline">\(b_1 = 0\)</span>, <span class="math inline">\(a_2
= -1\)</span>, and <span class="math inline">\(b_2 = 1\)</span>. In
order to solve this problem, we first have to re-formulate the
constraints to be of the form <span class="math inline">\(g(x)
\leq 0\)</span>. Note that the first constraint is a bound on <span class="math inline">\(x_2\)</span>, which we will add later. The other
two constraints can be re-written as:</p>
<p><span class="math display">\[
\begin{aligned}
(a_1 x_1 + b_1)^3 - x_2 &amp;\leq 0 \\
(a_2 x_1 + b_2)^3 - x_2 &amp;\leq 0
\end{aligned}
\]</span></p>
<p>First, define R functions to calculate the objective function and its
gradient:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># objective function</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>eval_f0 <span class="ot">&lt;-</span> <span class="cf">function</span>(x, a, b) {</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  <span class="fu">sqrt</span>(x[<span class="dv">2</span>])</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>}</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co"># gradient of objective function</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>eval_grad_f0 <span class="ot">&lt;-</span> <span class="cf">function</span>(x, a, b) {</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>  <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.5</span> <span class="sc">/</span> <span class="fu">sqrt</span>(x[<span class="dv">2</span>]))</span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>}</span></code></pre></div>
<p>If needed, these can of course be calculated in the same function as
before. Then define the two constraints and the Jacobian of the
constraints:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="co"># constraint function</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>eval_g0 <span class="ot">&lt;-</span> <span class="cf">function</span>(x, a, b) {</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  (a <span class="sc">*</span> x[<span class="dv">1</span>] <span class="sc">+</span> b) <span class="sc">^</span> <span class="dv">3</span> <span class="sc">-</span> x[<span class="dv">2</span>]</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>}</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co"># Jacobian of constraint</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>eval_jac_g0 <span class="ot">&lt;-</span> <span class="cf">function</span>(x, a, b) {</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>  <span class="fu">rbind</span>(<span class="fu">c</span>(<span class="dv">3</span> <span class="sc">*</span> a[<span class="dv">1</span>] <span class="sc">*</span> (a[<span class="dv">1</span>] <span class="sc">*</span> x[<span class="dv">1</span>] <span class="sc">+</span> b[<span class="dv">1</span>]) <span class="sc">^</span> <span class="dv">2</span>, <span class="sc">-</span><span class="fl">1.0</span>),</span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>        <span class="fu">c</span>(<span class="dv">3</span> <span class="sc">*</span> a[<span class="dv">2</span>] <span class="sc">*</span> (a[<span class="dv">2</span>] <span class="sc">*</span> x[<span class="dv">1</span>] <span class="sc">+</span> b[<span class="dv">2</span>]) <span class="sc">^</span> <span class="dv">2</span>, <span class="sc">-</span><span class="fl">1.0</span>))</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>}</span></code></pre></div>
<p>Note that all of the functions above depend on additional parameters,
<code>a</code> and <code>b</code>. We have to supply specific values for
these when we invoke the optimization command. The constraint function
<code>eval_g0</code> returns a vector with in this case the same length
as the vectors <code>a</code> and <code>b</code>. The function
calculating the Jacobian of the constraint should return a matrix where
the number of rows equal the number of constraints (in this case two).
The number of columns should equal the number of control variables (two
in this case as well).</p>
<p>After defining values for the parameters</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="co"># define parameters</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>a <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)</span></code></pre></div>
<p>we can minimize the function subject to the constraints with the
following command:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="co"># Solve using NLOPT_LD_MMA with gradient information supplied in separate</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="co"># function</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>res0 <span class="ot">&lt;-</span> <span class="fu">nloptr</span>(<span class="at">x0 =</span> <span class="fu">c</span>(<span class="fl">1.234</span>, <span class="fl">5.678</span>),</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>               <span class="at">eval_f =</span> eval_f0,</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>               <span class="at">eval_grad_f =</span> eval_grad_f0,</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>               <span class="at">lb =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="cn">Inf</span>, <span class="dv">0</span>),</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a>               <span class="at">ub =</span> <span class="fu">c</span>(<span class="cn">Inf</span>, <span class="cn">Inf</span>),</span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a>               <span class="at">eval_g_ineq =</span> eval_g0,</span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a>               <span class="at">eval_jac_g_ineq =</span> eval_jac_g0,</span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a>               <span class="at">opts =</span> <span class="fu">list</span>(<span class="st">&quot;algorithm&quot;</span> <span class="ot">=</span> <span class="st">&quot;NLOPT_LD_MMA&quot;</span>,</span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a>                           <span class="st">&quot;xtol_rel&quot;</span> <span class="ot">=</span> <span class="fl">1.0e-8</span>,</span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a>                           <span class="st">&quot;print_level&quot;</span> <span class="ot">=</span> <span class="dv">2</span>,</span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a>                           <span class="st">&quot;check_derivatives&quot;</span> <span class="ot">=</span> <span class="cn">TRUE</span>,</span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a>                           <span class="st">&quot;check_derivatives_print&quot;</span> <span class="ot">=</span> <span class="st">&quot;all&quot;</span>),</span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a>               <span class="at">a =</span> a,</span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a>               <span class="at">b =</span> b)</span></code></pre></div>
<pre><code>## Checking gradients of objective function.</code></pre>
<pre><code>## Derivative checker results: 0 error(s) detected.</code></pre>
<pre><code>## 
##   eval_grad_f[1] = 0.000000e+00 ~ 0.000000e+00   [0.000000e+00]
##   eval_grad_f[2] = 2.098323e-01 ~ 2.098323e-01   [1.422937e-09]</code></pre>
<pre><code>## Checking gradients of inequality constraints.</code></pre>
<pre><code>## Derivative checker results: 0 error(s) detected.</code></pre>
<pre><code>## 
##   eval_jac_g_ineq[1, 1] =  3.654614e+01 ~  3.654614e+01   [1.667794e-08]
##   eval_jac_g_ineq[2, 1] = -1.642680e-01 ~ -1.642680e-01   [2.103453e-07]
##   eval_jac_g_ineq[1, 2] = -1.000000e+00 ~ -1.000000e+00   [0.000000e+00]
##   eval_jac_g_ineq[2, 2] = -1.000000e+00 ~ -1.000000e+00   [0.000000e+00]</code></pre>
<pre><code>## iteration: 1
##  f(x) = 2.382855
##  g(x) = (9.354647, -5.690813)
## iteration: 2
##  f(x) = 2.356135
##  g(x) = (-0.122988, -5.549587)
## iteration: 3
##  f(x) = 2.245864
##  g(x) = (-0.531886, -5.038655)
## iteration: 4
##  f(x) = 2.019102
##  g(x) = (-3.225103, -3.931195)
## iteration: 5
##  f(x) = 1.740934
##  g(x) = (-2.676263, -2.761136)
## iteration: 6
##  f(x) = 1.404206
##  g(x) = (-1.674056, -1.676216)
## iteration: 7
##  f(x) = 1.022295
##  g(x) = (-0.748790, -0.748792)
## iteration: 8
##  f(x) = 0.685203
##  g(x) = (-0.173206, -0.173207)
## iteration: 9
##  f(x) = 0.552985
##  g(x) = (-0.009496, -0.009496)
## iteration: 10
##  f(x) = 0.544354
##  g(x) = (-0.000025, -0.000025)
## iteration: 11
##  f(x) = 0.544331
##  g(x) = (0.000000, 0.000000)
## iteration: 12
##  f(x) = 0.544331
##  g(x) = (0.000000, 0.000000)
## iteration: 13
##  f(x) = 0.544331
##  g(x) = (0.000000, 0.000000)
## iteration: 14
##  f(x) = 0.544331
##  g(x) = (0.000000, 0.000000)
## iteration: 15
##  f(x) = 0.544331
##  g(x) = (0.000000, 0.000000)
## iteration: 16
##  f(x) = 0.544331
##  g(x) = (0.000000, 0.000000)
## iteration: 17
##  f(x) = 0.544331
##  g(x) = (0.000000, 0.000000)
## iteration: 18
##  f(x) = 0.544331
##  g(x) = (0.000000, 0.000000)</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">print</span>(res0)</span></code></pre></div>
<pre><code>## 
## Call:
## 
## nloptr(x0 = c(1.234, 5.678), eval_f = eval_f0, eval_grad_f = eval_grad_f0, 
##     lb = c(-Inf, 0), ub = c(Inf, Inf), eval_g_ineq = eval_g0, 
##     eval_jac_g_ineq = eval_jac_g0, opts = list(algorithm = &quot;NLOPT_LD_MMA&quot;, 
##         xtol_rel = 1e-08, print_level = 2, check_derivatives = TRUE, 
##         check_derivatives_print = &quot;all&quot;), a = a, b = b)
## 
## 
## Minimization using NLopt version 2.7.1 
## 
## NLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization 
## stopped because xtol_rel or xtol_abs (above) was reached. 
## )
## 
## Number of Iterations....: 18 
## Termination conditions:  xtol_rel: 1e-08 
## Number of inequality constraints:  2 
## Number of equality constraints:    0 
## Optimal value of objective function:  0.544331047591509 
## Optimal value of controls: 0.3333333 0.2962963</code></pre>
<p>Here we supplied lower bounds for <span class="math inline">\(x_2\)</span> in <code>lb</code>. There are no
upper bounds for both control variables, so we supply <code>Inf</code>
values. If we don’t supply lower or upper bounds, plus or minus infinity
is chosen by default. The inequality constraints and its Jacobian are
defined using <code>eval_g_ineq</code> and <code>eval_jac_g_ineq</code>.
Not all algorithms can handle inequality constraints, so we have to
specify one that does, <code>NLOPT_LD_MMA</code> <span class="citation">(Svanberg 2002)</span>.</p>
<p>We also specify the option <code>print_level</code> to obtain output
during the optimization process. For the available
<code>print_level</code> values, see <code>?nloptr</code>. Setting the
<code>check_derivatives</code> option to <code>TRUE</code>, compares the
gradients supplied by the user with a finite difference approximation in
the initial point (<code>x0</code>). When this check is run, the option
<code>check_derivatives_print</code> can be used to print all values of
the derivative checker (<code>all</code> (default)), only those values
that result in an error (<code>errors</code>) or no output
(<code>none</code>), in which case only the number of errors is shown.
The tolerance that determines if a difference between the analytic
gradient and the finite difference approximation results in an error can
be set using the option <code>check_derivatives_tol</code> (default =
1e-04). The first column shows the value of the analytic gradient, the
second column shows the value of the finite difference approximation,
and the third column shows the relative error. Stars are added at the
front of a line if the relative error is larger than the specified
tolerance.</p>
<p>Finally, we add all the parameters that have to be passed on to the
objective and constraint functions, <code>a</code> and
<code>b</code>.</p>
<p>We can also use a different algorithm to solve the same minimization
problem. The only thing we have to change is the algorithm that we want
to use, in this case <code>NLOPT_LN_COBYLA</code>, which is an algorithm
that doesn’t need gradient information <span class="citation">(Powell
1994, 1998)</span>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="co"># Solve using NLOPT_LN_COBYLA without gradient information</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>res1 <span class="ot">&lt;-</span> <span class="fu">nloptr</span>(<span class="at">x0 =</span> <span class="fu">c</span>(<span class="fl">1.234</span>, <span class="fl">5.678</span>),</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>               <span class="at">eval_f =</span> eval_f0,</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>               <span class="at">lb =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="cn">Inf</span>, <span class="dv">0</span>),</span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>               <span class="at">ub =</span> <span class="fu">c</span>(<span class="cn">Inf</span>, <span class="cn">Inf</span>),</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a>               <span class="at">eval_g_ineq =</span> eval_g0,</span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a>               <span class="at">opts =</span> <span class="fu">list</span>(<span class="st">&quot;algorithm&quot;</span> <span class="ot">=</span> <span class="st">&quot;NLOPT_LN_COBYLA&quot;</span>,</span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>                           <span class="st">&quot;xtol_rel&quot;</span> <span class="ot">=</span> <span class="fl">1.0e-8</span>),</span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a>               <span class="at">a =</span> a,</span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a>               <span class="at">b =</span> b)</span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a><span class="fu">print</span>(res1)</span></code></pre></div>
<pre><code>## 
## Call:
## 
## nloptr(x0 = c(1.234, 5.678), eval_f = eval_f0, lb = c(-Inf, 0), 
##     ub = c(Inf, Inf), eval_g_ineq = eval_g0, opts = list(algorithm = &quot;NLOPT_LN_COBYLA&quot;, 
##         xtol_rel = 1e-08), a = a, b = b)
## 
## 
## Minimization using NLopt version 2.7.1 
## 
## NLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization 
## stopped because xtol_rel or xtol_abs (above) was reached. 
## )
## 
## Number of Iterations....: 50 
## Termination conditions:  xtol_rel: 1e-08 
## Number of inequality constraints:  2 
## Number of equality constraints:    0 
## Optimal value of objective function:  0.544331053951819 
## Optimal value of controls: 0.3333333 0.2962963</code></pre>
</div>
<div id="derivative-checker" class="section level2">
<h2>Derivative checker</h2>
<p>The derivative checker can be called when supplying a minimization
problem to <code>nloptr</code>, using the options
<code>check_derivatives</code>, <code>check_derivatives_tol</code> and
<code>check_derivatives_print</code>, but it can also be used
separately. For example, define the function <code>g</code>, with vector
outcome, and its gradient <code>g_grad</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="cf">function</span>(x, a) {</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>  <span class="fu">c</span>(x[<span class="dv">1</span>] <span class="sc">-</span> a[<span class="dv">1</span>],</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>    x[<span class="dv">2</span>] <span class="sc">-</span> a[<span class="dv">2</span>],</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>    (x[<span class="dv">1</span>] <span class="sc">-</span> a[<span class="dv">1</span>]) <span class="sc">^</span> <span class="dv">2</span>,</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>    (x[<span class="dv">2</span>] <span class="sc">-</span> a[<span class="dv">2</span>]) <span class="sc">^</span> <span class="dv">2</span>,</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>    (x[<span class="dv">1</span>] <span class="sc">-</span> a[<span class="dv">1</span>]) <span class="sc">^</span> <span class="dv">3</span>,</span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>    (x[<span class="dv">2</span>] <span class="sc">-</span> a[<span class="dv">2</span>]) <span class="sc">^</span> <span class="dv">3</span>)</span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a>}</span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" tabindex="-1"></a>g_grad <span class="ot">&lt;-</span> <span class="cf">function</span>(x, a) {</span>
<span id="cb30-11"><a href="#cb30-11" tabindex="-1"></a>  <span class="fu">rbind</span>(</span>
<span id="cb30-12"><a href="#cb30-12" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb30-13"><a href="#cb30-13" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>),</span>
<span id="cb30-14"><a href="#cb30-14" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">2</span> <span class="sc">*</span> (x[<span class="dv">1</span>] <span class="sc">-</span> a[<span class="dv">1</span>]), <span class="dv">0</span>),</span>
<span id="cb30-15"><a href="#cb30-15" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">2</span> <span class="sc">*</span> (x[<span class="dv">1</span>] <span class="sc">-</span> a[<span class="dv">1</span>]), <span class="dv">2</span> <span class="sc">*</span> (x[<span class="dv">2</span>] <span class="sc">-</span> a[<span class="dv">2</span>])),</span>
<span id="cb30-16"><a href="#cb30-16" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">3</span> <span class="sc">*</span> (x[<span class="dv">1</span>] <span class="sc">-</span> a[<span class="dv">2</span>]) <span class="sc">^</span> <span class="dv">2</span>, <span class="dv">0</span>),</span>
<span id="cb30-17"><a href="#cb30-17" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">3</span> <span class="sc">*</span> (x[<span class="dv">2</span>] <span class="sc">-</span> a[<span class="dv">2</span>]) <span class="sc">^</span> <span class="dv">2</span>)</span>
<span id="cb30-18"><a href="#cb30-18" tabindex="-1"></a>  )</span>
<span id="cb30-19"><a href="#cb30-19" tabindex="-1"></a>}</span></code></pre></div>
<p><code>a</code> is some vector containing data. The gradient contains
some errors in this case. By calling the function
<code>check.derivatives</code> we can check the user-supplied analytic
gradients with a finite difference approximation at a point
<code>.x</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">check.derivatives</span>(</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>  <span class="at">.x =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>),</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>  <span class="at">func =</span> g,</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>  <span class="at">func_grad =</span> g_grad,</span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>  <span class="at">check_derivatives_print =</span> <span class="st">&quot;all&quot;</span>,</span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>  <span class="at">a =</span> <span class="fu">c</span>(<span class="fl">0.3</span>, <span class="fl">0.8</span>)</span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## Derivative checker results: 2 error(s) detected.</code></pre>
<pre><code>## 
##   grad_f[1, 1] = 1.00e+00 ~ 1.00e+00   [0.000000e+00]
##   grad_f[2, 1] = 0.00e+00 ~ 0.00e+00   [0.000000e+00]
##   grad_f[3, 1] = 1.40e+00 ~ 1.40e+00   [9.579318e-09]
## * grad_f[4, 1] = 1.40e+00 ~ 0.00e+00   [1.400000e+00]
## * grad_f[5, 1] = 1.20e-01 ~ 1.47e+00   [9.183673e-01]
##   grad_f[6, 1] = 0.00e+00 ~ 0.00e+00   [0.000000e+00]
##   grad_f[1, 2] = 0.00e+00 ~ 0.00e+00   [0.000000e+00]
##   grad_f[2, 2] = 1.00e+00 ~ 1.00e+00   [0.000000e+00]
##   grad_f[3, 2] = 0.00e+00 ~ 0.00e+00   [0.000000e+00]
##   grad_f[4, 2] = 2.40e+00 ~ 2.40e+00   [1.179675e-08]
##   grad_f[5, 2] = 0.00e+00 ~ 0.00e+00   [0.000000e+00]
##   grad_f[6, 2] = 4.32e+00 ~ 4.32e+00   [2.593906e-08]</code></pre>
<p>The errors are shown on screen, where the option
<code>check_derivatives_print</code> determines the amount of output you
see. The value of the analytic gradient and the value of the finite
difference approximation at the supplied point is returned in a
list.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>res</span></code></pre></div>
<pre><code>## $analytic
##      [,1] [,2]
## [1,] 1.00 0.00
## [2,] 0.00 1.00
## [3,] 1.40 0.00
## [4,] 1.40 2.40
## [5,] 0.12 0.00
## [6,] 0.00 4.32
## 
## $finite_difference
##      [,1] [,2]
## [1,] 1.00 0.00
## [2,] 0.00 1.00
## [3,] 1.40 0.00
## [4,] 0.00 2.40
## [5,] 1.47 0.00
## [6,] 0.00 4.32
## 
## $relative_error
##              [,1]         [,2]
## [1,] 0.000000e+00 0.000000e+00
## [2,] 0.000000e+00 0.000000e+00
## [3,] 9.579318e-09 0.000000e+00
## [4,] 1.400000e+00 1.179675e-08
## [5,] 9.183673e-01 0.000000e+00
## [6,] 0.000000e+00 2.593906e-08
## 
## $flag_derivative_warning
##       [,1]  [,2]
## [1,] FALSE FALSE
## [2,] FALSE FALSE
## [3,] FALSE FALSE
## [4,]  TRUE FALSE
## [5,]  TRUE FALSE
## [6,] FALSE FALSE</code></pre>
<p>Note that not all errors will be picked up by the derivative checker.
For instance, if we run the check with <code>a = c(.5, .5)</code>, one
of the errors is not flagged as an error.</p>
</div>
<div id="notes" class="section level2">
<h2>Notes</h2>
<p>The <code>.R</code> scripts in the <code>tests</code> directory
contain more examples. For instance, <code>hs071.R</code> and
<code>systemofeq.R</code> show how to solve problems with equality
constraints. See the <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#augmented-lagrangian-algorithm">NLopt
website</a> for more details. Please let us know if there are any of
features implemented in NLopt which should be implemented in
<code>nloptr</code>.</p>
<p>Sometimes the optimization procedure terminates with a message
<code>maxtime was reached</code> without evaluating the objective
function. Submitting the same problem again usually solves this
problem.</p>
</div>
<div id="description-of-options" class="section level2">
<h2>Description of options</h2>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>nloptr<span class="sc">::</span><span class="fu">nloptr.print.options</span>()</span></code></pre></div>
<pre><code>## algorithm
##  possible values: NLOPT_GN_DIRECT, NLOPT_GN_DIRECT_L,
##           NLOPT_GN_DIRECT_L_RAND, NLOPT_GN_DIRECT_NOSCAL,
##           NLOPT_GN_DIRECT_L_NOSCAL,
##           NLOPT_GN_DIRECT_L_RAND_NOSCAL,
##           NLOPT_GN_ORIG_DIRECT, NLOPT_GN_ORIG_DIRECT_L,
##           NLOPT_GD_STOGO, NLOPT_GD_STOGO_RAND,
##           NLOPT_LD_SLSQP, NLOPT_LD_LBFGS_NOCEDAL,
##           NLOPT_LD_LBFGS, NLOPT_LN_PRAXIS, NLOPT_LD_VAR1,
##           NLOPT_LD_VAR2, NLOPT_LD_TNEWTON,
##           NLOPT_LD_TNEWTON_RESTART,
##           NLOPT_LD_TNEWTON_PRECOND,
##           NLOPT_LD_TNEWTON_PRECOND_RESTART,
##           NLOPT_GN_CRS2_LM, NLOPT_GN_MLSL, NLOPT_GD_MLSL,
##           NLOPT_GN_MLSL_LDS, NLOPT_GD_MLSL_LDS,
##           NLOPT_LD_MMA, NLOPT_LD_CCSAQ, NLOPT_LN_COBYLA,
##           NLOPT_LN_NEWUOA, NLOPT_LN_NEWUOA_BOUND,
##           NLOPT_LN_NELDERMEAD, NLOPT_LN_SBPLX,
##           NLOPT_LN_AUGLAG, NLOPT_LD_AUGLAG,
##           NLOPT_LN_AUGLAG_EQ, NLOPT_LD_AUGLAG_EQ,
##           NLOPT_LN_BOBYQA, NLOPT_GN_ISRES
##  default value:   none
## 
##  This option is required. Check the NLopt website for a description of
##  the algorithms.
## 
## stopval
##  possible values: -Inf &lt;= stopval &lt;= Inf
##  default value:   -Inf
## 
##  Stop minimization when an objective value &lt;= stopval is found.
##  Setting stopval to -Inf disables this stopping criterion (default).
## 
## ftol_rel
##  possible values: ftol_rel &gt; 0
##  default value:   0.0
## 
##  Stop when an optimization step (or an estimate of the optimum)
##  changes the objective function value by less than ftol_rel multiplied
##  by the absolute value of the function value. If there is any chance
##  that your optimum function value is close to zero, you might want to
##  set an absolute tolerance with ftol_abs as well. Criterion is
##  disabled if ftol_rel is non-positive (default).
## 
## ftol_abs
##  possible values: ftol_abs &gt; 0
##  default value:   0.0
## 
##  Stop when an optimization step (or an estimate of the optimum)
##  changes the function value by less than ftol_abs. Criterion is
##  disabled if ftol_abs is non-positive (default).
## 
## xtol_rel
##  possible values: xtol_rel &gt; 0
##  default value:   1.0e-04
## 
##  Stop when an optimization step (or an estimate of the optimum)
##  changes every parameter by less than xtol_rel multiplied by the
##  absolute value of the parameter. If there is any chance that an
##  optimal parameter is close to zero, you might want to set an absolute
##  tolerance with xtol_abs as well. Criterion is disabled if xtol_rel is
##  non-positive.
## 
## xtol_abs
##  possible values: xtol_abs &gt; 0
##  default value:   rep(0.0, length(x0))
## 
##  xtol_abs is a vector of length n (the number of elements in x) giving
##  the tolerances: stop when an optimization step (or an estimate of the
##  optimum) changes every parameter x[i] by less than xtol_abs[i].
##  Criterion is disabled if all elements of xtol_abs are non-positive
##  (default).
## 
## maxeval
##  possible values: maxeval is a positive integer
##  default value:   100
## 
##  Stop when the number of function evaluations exceeds maxeval. This is
##  not a strict maximum: the number of function evaluations may exceed
##  maxeval slightly, depending upon the algorithm. Criterion is disabled
##  if maxeval is non-positive.
## 
## maxtime
##  possible values: maxtime &gt; 0
##  default value:   -1.0
## 
##  Stop when the optimization time (in seconds) exceeds maxtime. This is
##  not a strict maximum: the time may exceed maxtime slightly, depending
##  upon the algorithm and on how slow your function evaluation is.
##  Criterion is disabled if maxtime is non-positive (default).
## 
## tol_constraints_ineq
##  possible values: tol_constraints_ineq &gt; 0.0
##  default value:   rep(1e-8, num_constraints_ineq)
## 
##  The parameter tol_constraints_ineq is a vector of tolerances. Each
##  tolerance corresponds to one of the inequality constraints. The
##  tolerance is used for the purpose of stopping criteria only: a point
##  x is considered feasible for judging whether to stop the optimization
##  if eval_g_ineq(x) &lt;= tol. A tolerance of zero means that NLopt will
##  try not to consider any x to be converged unless eval_g_ineq(x) is
##  strictly non-positive; generally, at least a small positive tolerance
##  is advisable to reduce sensitivity to rounding errors. By default the
##  tolerances for all inequality constraints are set to 1e-8.
## 
## tol_constraints_eq
##  possible values: tol_constraints_eq &gt; 0.0
##  default value:   rep(1e-8, num_constraints_eq)
## 
##  The parameter tol_constraints_eq is a vector of tolerances. Each
##  tolerance corresponds to one of the equality constraints. The
##  tolerance is used for the purpose of stopping criteria only: a point
##  x is considered feasible for judging whether to stop the optimization
##  if abs(eval_g_ineq(x)) &lt;= tol. For equality constraints, a small
##  positive tolerance is strongly advised in order to allow NLopt to
##  converge even if the equality constraint is slightly nonzero. By
##  default the tolerances for all quality constraints are set to 1e-8.
## 
## print_level
##  possible values: 0, 1, 2, or 3
##  default value:   0
## 
##  The option print_level controls how much output is shown during the
##  optimization process. Possible values: 0 (default): no output; 1:
##  show iteration number and value of objective function; 2: 1 + show
##  value of (in)equalities; 3: 2 + show value of controls.
## 
## check_derivatives
##  possible values: TRUE or FALSE
##  default value:   FALSE
## 
##  The option check_derivatives can be activated to compare the
##  user-supplied analytic gradients with finite difference
##  approximations.
## 
## check_derivatives_tol
##  possible values: check_derivatives_tol &gt; 0.0
##  default value:   1e-04
## 
##  The option check_derivatives_tol determines when a difference between
##  an analytic gradient and its finite difference approximation is
##  flagged as an error.
## 
## check_derivatives_print
##  possible values: &#39;none&#39;, &#39;all&#39;, &#39;errors&#39;,
##  default value:   all
## 
##  The option check_derivatives_print controls the output of the
##  derivative checker (if check_derivatives == TRUE). All comparisons
##  are shown (&#39;all&#39;), only those comparisions that resulted in an error
##  (&#39;error&#39;), or only the number of errors is shown (&#39;none&#39;).
## 
## print_options_doc
##  possible values: TRUE or FALSE
##  default value:   FALSE
## 
##  If TRUE, a description of all options and their current and default
##  values is printed to the screen.
## 
## population
##  possible values: population is a positive integer
##  default value:   0
## 
##  Several of the stochastic search algorithms (e.g., CRS, MLSL, and
##  ISRES) start by generating some initial population of random points
##  x. By default, this initial population size is chosen heuristically
##  in some algorithm-specific way, but the initial population can by
##  changed by setting a positive integer value for population. A
##  population of zero implies that the heuristic default will be used.
## 
## vector_storage
##  possible values: vector_storage is a positive integer
##  default value:   20
## 
##  Number of gradients to remember from previous optimization steps.
## 
## ranseed
##  possible values: ranseed is a positive integer
##  default value:   0
## 
##  For stochastic optimization algorithms, pseudorandom numbers are
##  generated. Set the random seed using ranseed if you want to use a
##  &#39;deterministic&#39; sequence of pseudorandom numbers, i.e. the same
##  sequence from run to run. If ranseed is 0 (default), the seed for the
##  random numbers is generated from the system time, so that you will
##  get a different sequence of pseudorandom numbers each time you run
##  your program.</code></pre>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-NLopt:website" class="csl-entry">
Johnson, Steven G. n.d. <span>“The <span>N</span><span>L</span>opt
Nonlinear-Optimization Package.”</span> <a href="https://nlopt.readthedocs.io/en/latest/">https://nlopt.readthedocs.io/en/latest/</a>.
</div>
<div id="ref-LiuNocedal:1989" class="csl-entry">
Liu, D. C., and J. Nocedal. 1989. <span>“On the Limited Memory
<span>B</span><span>F</span><span>G</span><span>S</span> Method for
Large Scale Optimization.”</span> <em>Math. Programming</em> 45: 503–28.
</div>
<div id="ref-Nocedal:1980" class="csl-entry">
Nocedal, J. 1980. <span>“Updating Quasi-<span>N</span>ewton Matrices
with Limited Storage.”</span> <em>Math. Comput.</em> 35: 773–82.
</div>
<div id="ref-Powell:1994" class="csl-entry">
Powell, M. J. D. 1994. <span>“A Direct Search Optimization Method That
Models the Objective and Constraint Functions by Linear
Interpolation.”</span> In <em>Advances in Optimization and Numerical
Analysis</em>, edited by S. Gomez and J.-P. Hennart, 51–67. Kluwer
Academic, Dordrecht.
</div>
<div id="ref-Powell:1998" class="csl-entry">
———. 1998. <span>“Direct Search Algorithms for Optimization
Calculations.”</span> <em>Acta Numerica</em> 7: 287–336.
</div>
<div id="ref-Svanberg:2002" class="csl-entry">
Svanberg, Krister. 2002. <span>“A Class of Globally Convergent
Optimization Methods Based on Conservative Convex Separable
Approximations.”</span> <em>SIAM J. Optim.</em> 12 (2): 555–73.
</div>
<div id="ref-Xie:2014" class="csl-entry">
Xie, Yihui. 2014. <span>“Knitr: A Comprehensive Tool for Reproducible
Research in <span>R</span>.”</span> In <em>Implementing Reproducible
Computational Research</em>, edited by Victoria Stodden, Friedrich
Leisch, and Roger D. Peng. Chapman; Hall/CRC. <a href="https://www.routledge.com/Implementing-Reproducible-Research/Stodden-Leisch-Peng/p/book/9781466561595">https://www.routledge.com/Implementing-Reproducible-Research/Stodden-Leisch-Peng/p/book/9781466561595</a>.
</div>
<div id="ref-Xie:2015" class="csl-entry">
———. 2015. <em>Dynamic Documents with <span>R</span> and Knitr</em>. 2nd
ed. Boca Raton, Florida: Chapman; Hall/CRC. <a href="https://yihui.org/knitr/">https://yihui.org/knitr/</a>.
</div>
<div id="ref-Xie:2016" class="csl-entry">
———. 2016. <em>Knitr: A General-Purpose Package for Dynamic Report
Generation in r</em>. <a href="https://yihui.org/knitr/">https://yihui.org/knitr/</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
